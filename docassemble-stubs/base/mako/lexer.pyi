from _typeshed import Incomplete as Incomplete

class Lexer:
    text: Incomplete
    filename: Incomplete
    template: Incomplete
    matched_lineno: int
    matched_charpos: int
    lineno: int
    match_position: int
    tag: Incomplete
    control_line: Incomplete
    ternary_stack: Incomplete
    encoding: Incomplete
    preprocessor: Incomplete
    def __init__(self, text, filename: Union[Incomplete, None] = ..., input_encoding: Union[Incomplete, None] = ..., preprocessor: Union[Incomplete, None] = ...) -> None: ...
    @property
    def exception_kwargs(self) -> None: ...
    def match(self, regexp, flags: Union[Incomplete, None] = ...): ...
    def match_reg(self, reg) -> None: ...
    def parse_until_text(self, watch_nesting, *text) -> None: ...
    def append_node(self, nodecls, *args, **kwargs) -> None: ...
    def decode_raw_stream(self, text, decode_raw, known_encoding, filename) -> None: ...
    textlength: Incomplete
    def parse(self) -> None: ...
    keyword: Incomplete
    def match_tag_start(self) -> None: ...
    def match_tag_end(self) -> None: ...
    def match_end(self) -> None: ...
    def match_text(self) -> None: ...
    def match_python_block(self) -> None: ...
    def match_expression(self) -> None: ...
    def match_control_line(self) -> None: ...
    def match_comment(self) -> None: ...
