from _typeshed import Incomplete as Incomplete
from collections.abc import Generator
from html.parser import HTMLParser
from jinja2 import ChainableUndefined, FileSystemLoader
from jinja2.environment import Environment
from jinja2.ext import Extension
from jinja2.runtime import StrictUndefined
from typing import NamedTuple

equals_byte: Incomplete
RangeType: Incomplete
NoneType: Incomplete
da_arch: Incomplete
standard_types: Incomplete
DEBUG: bool
import_core: Incomplete
import_util: Incomplete
import_process_action: Incomplete
run_process_action: Incomplete
match_process_action: Incomplete
match_mako: Incomplete
emoji_match: Incomplete
valid_variable_match: Incomplete
nameerror_match: Incomplete
document_match: Incomplete
remove_trailing_dots: Incomplete
fix_tabs: Incomplete
dot_split: Incomplete
match_brackets_at_end: Incomplete
match_inside_brackets: Incomplete
match_brackets: Incomplete
match_brackets_or_dot: Incomplete
complications: Incomplete
list_of_indices: Incomplete
extension_of_doc_format: Incomplete
DO_NOT_TRANSLATE: str

def process_audio_video_list(the_list, the_user_dict) -> None: ...
def textify(data, the_user_dict) -> None: ...

INITIAL_DICT: Incomplete

def set_initial_dict(the_dict) -> None: ...
def get_initial_dict() -> None: ...

class DAFileSystemLoader(FileSystemLoader):
    def get_source(self, environment, template) -> None: ...

class PackageImage:
    filename: Incomplete
    attribution: Incomplete
    setname: Incomplete
    package: Incomplete
    def __init__(self, **kwargs) -> None: ...
    def get_filename(self) -> None: ...
    def get_reference(self) -> None: ...

class InterviewSource:
    package: Incomplete
    language: Incomplete
    dialect: Incomplete
    testing: Incomplete
    translating: Incomplete
    def __init__(self, **kwargs) -> None: ...
    def __le__(self, other): ...
    def __ge__(self, other): ...
    def __gt__(self, other): ...
    def __lt__(self, other): ...
    def __eq__(self, other): ...
    def __ne__(self, other): ...
    def __hash__(self): ...
    path: Incomplete
    def set_path(self, path) -> None: ...
    def get_name(self) -> None: ...
    def get_index(self) -> None: ...
    def update_index(self) -> None: ...
    filepath: Incomplete
    def set_filepath(self, filepath) -> None: ...
    directory: Incomplete
    def set_directory(self, directory) -> None: ...
    content: Incomplete
    def set_content(self, content) -> None: ...
    def set_language(self, language) -> None: ...
    def set_dialect(self, dialect) -> None: ...
    def set_testing(self, testing) -> None: ...
    def set_package(self, package) -> None: ...
    def update(self, **kwargs) -> None: ...
    def get_modtime(self) -> None: ...
    def get_language(self) -> None: ...
    def get_dialect(self) -> None: ...
    def get_package(self) -> None: ...
    def get_testing(self) -> None: ...
    def get_interview(self) -> None: ...
    def append(self, path) -> None: ...

class InterviewSourceString(InterviewSource):
    def __init__(self, **kwargs) -> None: ...

class InterviewSourceFile(InterviewSource):
    playground: Incomplete
    playground_file: Incomplete
    filepath: Incomplete
    def __init__(self, **kwargs) -> None: ...
    path: Incomplete
    package: Incomplete
    basename: Incomplete
    def set_path(self, path) -> None: ...
    directory: Incomplete
    def set_filepath(self, filepath) -> None: ...
    def reset_modtime(self) -> None: ...
    def update(self, **kwargs) -> None: ...
    def get_modtime(self) -> None: ...
    def append(self, path) -> None: ...

def dummy_embed_input(status, variable) -> None: ...

class InterviewStatus:
    current_info: Incomplete
    attributions: Incomplete
    seeking: Incomplete
    tracker: Incomplete
    maps: Incomplete
    extra_scripts: Incomplete
    extra_css: Incomplete
    using_screen_reader: bool
    can_go_back: bool
    attachments: Incomplete
    linkcounter: int
    embedded: Incomplete
    extras: Incomplete
    followed_mc: bool
    tentatively_answered: Incomplete
    checkin: bool
    def __init__(self, current_info: Union[Incomplete, None] = ..., **kwargs) -> None: ...
    def get_all_fields_used(self, user_dict) -> None: ...
    def get_fields_and_sub_fields_and_collect_fields(self, user_dict) -> None: ...
    def is_empty_mc(self, field) -> None: ...
    def get_field_info(self) -> None: ...
    def do_sleep(self) -> None: ...
    def get_field_list(self) -> None: ...
    def mark_tentative_as_answered(self, the_user_dict) -> None: ...
    screen_reader_text: Incomplete
    screen_reader_links: Incomplete
    def initialize_screen_reader(self) -> None: ...
    question: Incomplete
    questionText: Incomplete
    subquestionText: Incomplete
    continueLabel: Incomplete
    decorations: Incomplete
    audiovideo: Incomplete
    helpText: Incomplete
    interviewHelpText: Incomplete
    selectcompute: Incomplete
    defaults: Incomplete
    other_defaults: Incomplete
    hints: Incomplete
    helptexts: Incomplete
    labels: Incomplete
    sought: Incomplete
    orig_sought: Incomplete
    def populate(self, question_result) -> None: ...
    def set_tracker(self, tracker) -> None: ...
    def get_history(self) -> None: ...
    def convert_help(self, help_text, encode, debug) -> None: ...
    def as_data(self, the_user_dict, encode: bool = ...): ...
    def get_choices(self, field, the_user_dict) -> None: ...
    def icon_url(self, name) -> None: ...
    def get_choices_data(self, field, defaultvalue, the_user_dict, encode: bool = ...): ...

class TextObject:
    def __deepcopy__(self, memo) -> None: ...
    original_text: Incomplete
    other_lang: Incomplete
    template: Incomplete
    uses_mako: bool
    language: Incomplete
    def __init__(self, x, question: Union[Incomplete, None] = ..., translate: bool = ...) -> None: ...
    def text(self, the_user_dict) -> None: ...

def myb64quote(text) -> None: ...
def safeid(text) -> None: ...
def from_safeid(text) -> None: ...
def repad(text) -> None: ...

class Field:
    number: Incomplete
    saveas: Incomplete
    saveas_code: Incomplete
    showif_code: Incomplete
    action: Incomplete
    label: Incomplete
    datatype: Incomplete
    choicetype: Incomplete
    disableothers: Incomplete
    uncheckothers: Incomplete
    default: Incomplete
    combobox_action: Incomplete
    hint: Incomplete
    data: Incomplete
    helptext: Incomplete
    validate: Incomplete
    validation_messages: Incomplete
    address_autocomplete: Incomplete
    label_above_field: Incomplete
    floating_label: Incomplete
    max_image_size: Incomplete
    image_type: Incomplete
    accept: Incomplete
    permissions: Incomplete
    rows: Incomplete
    object_labeler: Incomplete
    help_generator: Incomplete
    image_generator: Incomplete
    extras: Incomplete
    selections: Incomplete
    sign: Incomplete
    inputtype: Incomplete
    fieldtype: str
    choices: Incomplete
    has_code: bool
    shuffle: Incomplete
    nota: Incomplete
    required: Incomplete
    def __init__(self, data) -> None: ...
    def validation_message(self, validation_type, status, default_message, parameters: Union[Incomplete, None] = ...): ...

def recursive_eval_dataobject(target, the_user_dict) -> None: ...
def recursive_eval_data_from_code(target, the_user_dict) -> None: ...
def recursive_textobject(target, question) -> None: ...
def recursive_eval_textobject(target, the_user_dict, question, tpl, skip_undefined) -> None: ...
def recursive_textobject_or_primitive(target, question) -> None: ...
def recursive_eval_textobject_or_primitive(target, the_user_dict) -> None: ...
def fix_quotes(match) -> None: ...
def docx_variable_fix(variable) -> None: ...
def url_sanitize(url) -> None: ...

class FileInPackage:
    fileref: Incomplete
    is_code: bool
    code: Incomplete
    area: Incomplete
    package: Incomplete
    def __init__(self, fileref, area, package) -> None: ...
    def path(self, the_user_dict: Union[Incomplete, None] = ...): ...
    def paths(self, the_user_dict: Union[Incomplete, None] = ...): ...

class FileOnServer:
    fileref: Incomplete
    question: Incomplete
    def __init__(self, fileref, question) -> None: ...
    def path(self) -> None: ...

class Question:
    def idebug(self, data) -> None: ...
    from_source: Incomplete
    package: Incomplete
    interview: Incomplete
    source_code: Incomplete
    fields: Incomplete
    attachments: Incomplete
    is_generic: bool
    name: Incomplete
    role: Incomplete
    condition: Incomplete
    terms: Incomplete
    autoterms: Incomplete
    need: Incomplete
    need_post: Incomplete
    scan_for_variables: bool
    embeds: bool
    helptext: Incomplete
    subcontent: Incomplete
    breadcrumb: Incomplete
    reload_after: Incomplete
    continuelabel: Incomplete
    backbuttonlabel: Incomplete
    cornerbackbuttonlabel: Incomplete
    helplabel: Incomplete
    helpheading: Incomplete
    progress: Incomplete
    section: Incomplete
    script: Incomplete
    css: Incomplete
    checkin: Incomplete
    target: Incomplete
    decorations: Incomplete
    audiovideo: Incomplete
    compute_attachment: Incomplete
    can_go_back: bool
    other_fields_used: Incomplete
    fields_used: Incomplete
    fields_for_invalidation: Incomplete
    fields_for_onchange: Incomplete
    names_used: Incomplete
    mako_names: Incomplete
    reconsider: Incomplete
    undefine: Incomplete
    action_buttons: Incomplete
    validation_code: Incomplete
    language: Incomplete
    back_button: Incomplete
    allowed_to_set: Incomplete
    skip_undefined: bool
    list_collect: Incomplete
    list_collect_label: Incomplete
    list_collect_is_final: Incomplete
    list_collect_allow_append: Incomplete
    list_collect_allow_delete: Incomplete
    list_collect_add_another_label: Incomplete
    is_mandatory: bool
    mandatory_code: Incomplete
    is_initial: bool
    initial_code: Incomplete
    question_type: Incomplete
    content: Incomplete
    objects_from_file: Incomplete
    objects: Incomplete
    id: Incomplete
    ga_id: Incomplete
    segment: Incomplete
    generic_object: Incomplete
    module_list: Incomplete
    reset_list: Incomplete
    require_list: Incomplete
    or_else_question: Incomplete
    allow_emailing: Incomplete
    allow_downloading: Incomplete
    email_subject: Incomplete
    email_body: Incomplete
    email_template: Incomplete
    email_default: Incomplete
    always_include_editable_files: Incomplete
    attachment_notice: Incomplete
    download_tab: Incomplete
    manual_attachment_list: Incomplete
    zip_filename: Incomplete
    action: Incomplete
    backgroundresponse: Incomplete
    binaryresponse: Incomplete
    all_variables: bool
    include_internal: Incomplete
    response_file: Incomplete
    content_type: Incomplete
    sleep: Incomplete
    response_code: Incomplete
    css_class: Incomplete
    table_css_class: Incomplete
    question_metadata: Incomplete
    undertext: Incomplete
    pretext: Incomplete
    posttext: Incomplete
    righttext: Incomplete
    question_variety: str
    review_saveas: Incomplete
    compute: Incomplete
    sourcecode: Incomplete
    fields_saveas: Incomplete
    number: Incomplete
    data_for_debug: Incomplete
    def __init__(self, orig_data, caller, **kwargs) -> None: ...
    def get_old_values(self, user_dict) -> None: ...
    def invalidate_dependencies_of_variable(self, the_user_dict, field_name, old_value) -> None: ...
    def invalidate_dependencies(self, the_user_dict, old_values) -> None: ...
    def post_exec(self, the_user_dict) -> None: ...
    def exec_setup(self, is_generic, the_x, iterators, the_user_dict) -> None: ...
    def recursive_data_from_code(self, target) -> None: ...
    def recursive_dataobject(self, target) -> None: ...
    def find_fields_in(self, code) -> None: ...
    def yes(self) -> None: ...
    def no(self) -> None: ...
    def maybe(self) -> None: ...
    def back(self) -> None: ...
    def cornerback(self) -> None: ...
    def help(self) -> None: ...
    def process_attachment_code(self, sourcecode) -> None: ...
    def process_attachment_list(self, target) -> None: ...
    def process_attachment(self, orig_target) -> None: ...
    def get_question_for_field_with_sub_fields(self, field, user_dict) -> None: ...
    def get_fields_and_sub_fields_used(self, user_dict) -> None: ...
    def get_fields_and_sub_fields(self, user_dict) -> None: ...
    def ask(self, user_dict, old_user_dict, the_x, iterators, sought, orig_sought, process_list_collect: bool = ..., test_for_objects: bool = ...): ...
    def processed_attachments(self, the_user_dict, **kwargs) -> None: ...
    def parse_fields(self, the_list, register_target, uses_field) -> None: ...
    def mark_as_answered(self, the_user_dict) -> None: ...
    def sub_fields_used(self) -> None: ...
    def extended_question_name(self, the_user_dict) -> None: ...
    def follow_multiple_choice(self, the_user_dict, interview_status, is_generic, the_x, iterators) -> None: ...
    def finalize_attachment(self, attachment, result, the_user_dict) -> None: ...
    def prepare_attachment(self, attachment, the_user_dict) -> None: ...
    def process_selections_manual(self, data) -> None: ...

def emoji_matcher_insert(obj) -> None: ...
def emoji_matcher_html(obj) -> None: ...
def interview_source_from_string(path, **kwargs) -> None: ...
def is_boolean(field_data) -> None: ...
def is_threestate(field_data) -> None: ...

class TableInfo: ...

def recursive_update(base, target) -> None: ...
def recursive_add_classes(class_list, the_class) -> None: ...
def unqualified_name(variable, the_user_dict) -> None: ...
def make_backup_vars(the_user_dict) -> None: ...
def restore_backup_vars(the_user_dict, backups) -> None: ...
def illegal_variable_name(var) -> None: ...

class Interview:
    source: Incomplete
    questions: Incomplete
    generic_questions: Incomplete
    questions_by_id: Incomplete
    questions_by_name: Incomplete
    questions_list: Incomplete
    all_questions: Incomplete
    progress_points: Incomplete
    ids_in_use: Incomplete
    id_orderings: Incomplete
    invalidation: Incomplete
    invalidation_todo: Incomplete
    onchange: Incomplete
    onchange_todo: Incomplete
    orderings: Incomplete
    orderings_by_question: Incomplete
    images: Incomplete
    metadata: Incomplete
    helptext: Incomplete
    defs: Incomplete
    terms: Incomplete
    mlfields: Incomplete
    autoterms: Incomplete
    includes: Incomplete
    reconsider: Incomplete
    reconsider_generic: Incomplete
    question_index: int
    block_index: int
    translating: bool
    default_role: Incomplete
    default_validation_messages: Incomplete
    default_screen_parts: Incomplete
    title: Incomplete
    debug: Incomplete
    use_progress_bar: bool
    question_back_button: bool
    question_help_button: bool
    navigation_back_button: bool
    force_fullscreen: bool
    use_pdf_a: Incomplete
    use_tagged_pdf: Incomplete
    loop_limit: Incomplete
    recursion_limit: Incomplete
    cache_documents: bool
    use_navigation: bool
    use_navigation_on_small_screens: bool
    flush_left: bool
    max_image_size: Incomplete
    image_type: Incomplete
    bootstrap_theme: Incomplete
    sections: Incomplete
    names_used: Incomplete
    attachment_options: Incomplete
    attachment_index: int
    external_files: Incomplete
    options: Incomplete
    calls_process_action: bool
    uses_action: bool
    imports_util: bool
    table_width: int
    success: bool
    translation_dict: Incomplete
    translations: Incomplete
    scan_for_emojis: bool
    consolidated_metadata: Incomplete
    issue: Incomplete
    custom_data_types: Incomplete
    default_language: Incomplete
    def __init__(self, **kwargs) -> None: ...
    def cross_reference_dependencies(self) -> None: ...
    def invalidate_dependencies(self, field_name, the_user_dict, old_values) -> None: ...
    def get_ml_store(self) -> None: ...
    ml_store: Incomplete
    def set_ml_store(self, ml_store) -> None: ...
    def standard_ml_store(self) -> None: ...
    def get_bootstrap_theme(self) -> None: ...
    def get_tags(self, the_user_dict) -> None: ...
    def get_title(self, the_user_dict, status: Union[Incomplete, None] = ..., converter: Union[Incomplete, None] = ...): ...
    def allowed_to_access(self, is_anonymous: bool = ..., has_roles: Union[Incomplete, None] = ...): ...
    def allowed_to_initiate(self, is_anonymous: bool = ..., has_roles: Union[Incomplete, None] = ...): ...
    def allowed_to_see_listed(self, is_anonymous: bool = ..., has_roles: Union[Incomplete, None] = ...): ...
    def is_unlisted(self) -> None: ...
    def next_attachment_number(self) -> None: ...
    def next_number(self) -> None: ...
    def next_block_number(self) -> None: ...
    sorter: Incomplete
    default_title: Incomplete
    def read_from(self, source) -> None: ...
    obj: Incomplete
    lookup: Incomplete
    def make_sorter(self) -> None: ...
    def sort_with_orderings(self, the_list) -> None: ...
    def processed_helptext(self, the_user_dict, language) -> None: ...
    def populate_non_pickleable(self, user_dict_copy) -> None: ...
    def assemble(self, user_dict, interview_status: Union[Incomplete, None] = ..., old_user_dict: Union[Incomplete, None] = ..., force_question: Union[Incomplete, None] = ...) -> None: ...
    def load_util(self, the_user_dict) -> None: ...
    def askfor(self, missingVariable, user_dict, old_user_dict, interview_status, **kwargs) -> None: ...

def substitute_vars(var, is_generic, the_x, iterators, last_only: bool = ...): ...
def substitute_vars_action(action, is_generic, the_x, iterators) -> None: ...
def reproduce_basics(interview, new_interview) -> None: ...
def unpack_list(item, target_list: Union[Incomplete, None] = ...): ...
def process_selections(data, exclude: Union[Incomplete, None] = ...): ...
def extract_missing_name(the_error) -> None: ...
def auto_determine_type(field_info, the_value: Union[Incomplete, None] = ...) -> None: ...
def get_mimetype(filename) -> None: ...
def interpret_label(text) -> None: ...
def recurse_indices(expression_array, variable_list, pre_part, final_list, var_subs_dict, var_subs, generic_dict, generic) -> None: ...
def ensure_object_exists(saveas, datatype, the_user_dict, commands: Union[Incomplete, None] = ...) -> None: ...
def invalid_variable_name(varname) -> None: ...
def exec_with_trap(the_question, the_dict, old_variable: Union[Incomplete, None] = ...) -> None: ...

ok_outside_string: Incomplete
ok_inside_string: Incomplete

def parse_var_name(var) -> None: ...

class DAExtension(Extension):
    def parse(self, parser) -> None: ...
    def filter_stream(self, stream) -> Generator[Incomplete, None, None]: ...

class DAEnvironment(Environment):
    def from_string(self, source, **kwargs) -> None: ...
    def getitem(self, obj, argument) -> None: ...
    def getattr(self, obj, attribute) -> None: ...

def ampersand_filter(value) -> None: ...

class DAStrictUndefined(StrictUndefined):
    def __init__(self, hint: Union[Incomplete, None] = ..., obj=..., name: Union[Incomplete, None] = ..., exc=..., accesstype: Union[Incomplete, None] = ...) -> None: ...
    def __getattr__(self, name) -> None: ...
    def __getitem__(self, index) -> None: ...
    __add__: Incomplete
    __radd__: Incomplete
    __mul__: Incomplete
    __rmul__: Incomplete
    __div__: Incomplete
    __rdiv__: Incomplete
    __truediv__: Incomplete
    __rtruediv__: Incomplete
    __floordiv__: Incomplete
    __rfloordiv__: Incomplete
    __mod__: Incomplete
    __rmod__: Incomplete
    __pos__: Incomplete
    __neg__: Incomplete
    __call__: Incomplete
    __lt__: Incomplete
    __le__: Incomplete
    __gt__: Incomplete
    __ge__: Incomplete
    __int__: Incomplete
    __float__: Incomplete
    __complex__: Incomplete
    __pow__: Incomplete
    __rpow__: Incomplete
    __sub__: Incomplete
    __rsub__: Incomplete
    __iter__: Incomplete
    __len__: Incomplete
    __nonzero__: Incomplete
    __eq__: Incomplete
    __ne__: Incomplete
    __bool__: Incomplete
    __hash__: Incomplete

class DASkipUndefined(ChainableUndefined):
    def __init__(self, *pargs, **kwargs) -> None: ...
    def __call__(self, *pargs, **kwargs) -> DASkipUndefined: ...
    __getitem__: Incomplete
    __getattr__: Incomplete
    def __eq__(self, *pargs) -> bool: ...
    __bool__: Incomplete
    __ne__: Incomplete
    __le__: Incomplete
    __lt__: Incomplete
    __gt__: Incomplete
    __ge__: Incomplete
    __nonzero__: Incomplete
    def __iter__(self, *pargs) -> DASkipUndefined: ...
    def __next__(self, *pargs) -> None: ...
    def __int__(self, *pargs) -> int: ...
    __len__: Incomplete
    def __float__(self, *pargs) -> float: ...
    def __complex__(self, *pargs) -> complex: ...
    def __add__(self, *pargs, **kwargs) -> str: ...
    __radd__: Incomplete
    __mul__: Incomplete
    __rmul__: Incomplete
    __div__: Incomplete
    __rdiv__: Incomplete
    __truediv__: Incomplete
    __rtruediv__: Incomplete
    __floordiv__: Incomplete
    __rfloordiv__: Incomplete
    __mod__: Incomplete
    __rmod__: Incomplete
    __pos__: Incomplete
    __neg__: Incomplete
    __pow__: Incomplete
    __rpow__: Incomplete
    __sub__: Incomplete
    __rsub__: Incomplete
    __hash__: Incomplete

def mygetattr(y, attr) -> None: ...
def str_or_original(y, case_sensitive) -> None: ...
def dictsort_filter(dictionary, case_sensitive: bool = ..., by: str = ..., reverse: bool = ...): ...
def sort_filter(the_array, reverse: bool = ..., case_sensitive: bool = ..., attribute: Union[Incomplete, None] = ...): ...

class _GroupTuple(NamedTuple):
    grouper: Incomplete
    list: Incomplete

def groupby_filter(the_array, attr_name) -> None: ...
def max_filter(the_array, case_sensitive: bool = ..., attribute: Union[Incomplete, None] = ...): ...
def min_filter(the_array, case_sensitive: bool = ..., attribute: Union[Incomplete, None] = ...): ...
def sum_filter(the_array, attribute: Union[Incomplete, None] = ..., start: int = ...): ...
def unique_filter(the_array, case_sensitive: bool = ..., attribute: Union[Incomplete, None] = ...) -> Generator[Incomplete, None, None]: ...
def join_filter(the_array, d: str = ..., attribute: Union[Incomplete, None] = ...): ...
def attr_filter(var, attr_name) -> None: ...
def selectattr_filter(*pargs, **kwargs) -> Generator[Incomplete, None, Incomplete]: ...
def rejectattr_filter(*pargs, **kwargs) -> Generator[Incomplete, None, Incomplete]: ...
def chain_filter(*pargs, **kwargs) -> None: ...
def map_filter(*pargs, **kwargs) -> Generator[Incomplete, None, None]: ...
def markdown_filter(text) -> None: ...
def inline_markdown_filter(text) -> None: ...

builtin_jinja_filters: Incomplete
registered_jinja_filters: Incomplete

def custom_jinja_env(skip_undefined: bool = ...): ...
def register_jinja_filter(filter_name, func) -> None: ...
def get_docx_variables(the_path) -> None: ...
def allow_users_list(obj) -> None: ...
def allow_privileges_list(obj) -> None: ...

class MLStripper(HTMLParser):
    strict: bool
    convert_charrefs: bool
    text: Incomplete
    def __init__(self) -> None: ...
    def handle_data(self, data) -> None: ...
    def get_data(self) -> None: ...

def strip_tags(html) -> None: ...
