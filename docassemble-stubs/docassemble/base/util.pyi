import datetime
import oauth2client.client
from _typeshed import Incomplete as Incomplete
from docassemble.base.functions import capitalize as capitalize

capitalize_func = capitalize

class DAEmpty:
    str: Incomplete
    def __init__(self, *pargs, **kwargs) -> None: ...
    def __getattr__(self, thename) -> None: ...
    def __dir__(self) -> None: ...
    def __contains__(self, item) -> bool: ...
    def __iter__(self): ...
    def __len__(self) -> int: ...
    def __reversed__(self) -> None: ...
    def __getitem__(self, index) -> None: ...
    def __setitem__(self, index, val) -> None: ...
    def __delitem__(self, index) -> None: ...
    def __call__(self, *pargs, **kwargs) -> None: ...
    def __add__(self, other) -> None: ...
    def __sub__(self, other) -> None: ...
    def __mul__(self, other) -> None: ...
    def __floordiv__(self, other) -> None: ...
    def __mod__(self, other) -> None: ...
    def __divmod__(self, other) -> None: ...
    def __pow__(self, other) -> None: ...
    def __lshift__(self, other) -> None: ...
    def __rshift__(self, other) -> None: ...
    def __and__(self, other) -> None: ...
    def __xor__(self, other) -> None: ...
    def __or__(self, other) -> None: ...
    def __div__(self, other) -> None: ...
    def __truediv__(self, other) -> None: ...
    def __radd__(self, other) -> None: ...
    def __rsub__(self, other) -> None: ...
    def __rmul__(self, other) -> None: ...
    def __rdiv__(self, other) -> None: ...
    def __rtruediv__(self, other) -> None: ...
    def __rfloordiv__(self, other) -> None: ...
    def __rmod__(self, other) -> None: ...
    def __rdivmod__(self, other) -> None: ...
    def __rpow__(self, other) -> None: ...
    def __rlshift__(self, other) -> None: ...
    def __rrshift__(self, other) -> None: ...
    def __rand__(self, other) -> None: ...
    def __ror__(self, other) -> None: ...
    def __neg__(self) -> None: ...
    def __pos__(self) -> None: ...
    def __abs__(self) -> None: ...
    def __invert__(self) -> None: ...
    def __complex__(self) -> complex: ...
    def __int__(self) -> int: ...
    def __float__(self) -> float: ...
    def __oct__(self) -> None: ...
    def __hex__(self) -> None: ...
    def __index__(self) -> int: ...
    def __le__(self, other): ...
    def __ge__(self, other): ...
    def __gt__(self, other): ...
    def __lt__(self, other): ...
    def __eq__(self, other): ...
    def __ne__(self, other): ...
    def __hash__(self): ...

class DAObjectPlusParameters: ...

class DAObject:
    def init(self, *pargs, **kwargs) -> None: ...
    @classmethod
    def using(cls, **kwargs) -> None: ...
    has_nonrandom_instance_name: bool
    instanceName: Incomplete
    attrList: Incomplete
    def __init__(self, *pargs, **kwargs) -> None: ...
    def attr_name(self, attr) -> None: ...
    def delattr(self, *pargs) -> None: ...
    def invalidate_attr(self, *pargs) -> None: ...
    def getattr_fresh(self, attr) -> None: ...
    def is_peer_relation(self, target, relationship_type, tree) -> None: ...
    def is_relation(self, target, relationship_type, tree, self_is: str = ..., filter_by: Union[Incomplete, None] = ...): ...
    def get_relation(self, relationship_type, tree, self_is: str = ..., create: bool = ..., object_type: Union[Incomplete, None] = ..., complete_attribute: Union[Incomplete, None] = ..., rel_filter_by: Union[Incomplete, None] = ..., filter_by: Union[Incomplete, None] = ..., count: int = ...): ...
    def get_peer_relation(self, relationship_type, tree, create: bool = ..., object_type: Union[Incomplete, None] = ..., complete_attribute: Union[Incomplete, None] = ..., rel_filter_by: Union[Incomplete, None] = ..., filter_by: Union[Incomplete, None] = ..., count: int = ...): ...
    def set_peer_relationship(self, target, relationship_type, tree, replace: bool = ...): ...
    def set_relationship(self, target, relationship_type, self_is, tree, replace: bool = ...): ...
    def fix_instance_name(self, old_instance_name, new_instance_name) -> None: ...
    def set_instance_name(self, thename) -> None: ...
    def set_random_instance_name(self) -> None: ...
    def copy_shallow(self, thename) -> None: ...
    def copy_deep(self, thename) -> None: ...
    def __getattr__(self, thename) -> None: ...
    def object_name(self, **kwargs) -> None: ...
    def as_serializable(self) -> None: ...
    def object_possessive(self, target, **kwargs) -> None: ...
    def initializeAttribute(self, *pargs, **kwargs) -> None: ...
    def reInitializeAttribute(self, *pargs, **kwargs) -> None: ...
    def attribute_defined(self, name) -> None: ...
    def attr(self, name) -> None: ...
    def __dir__(self) -> None: ...
    def pronoun_possessive(self, target, **kwargs) -> None: ...
    def pronoun(self, **kwargs) -> None: ...
    def alternative(self, *pargs, **kwargs) -> None: ...
    def pronoun_objective(self, **kwargs) -> None: ...
    def pronoun_subjective(self, **kwargs) -> None: ...
    def __setattr__(self, key, the_value) -> None: ...
    def __le__(self, other): ...
    def __ge__(self, other): ...
    def __gt__(self, other): ...
    def __lt__(self, other): ...
    def __eq__(self, other): ...
    def __ne__(self, other): ...
    def __hash__(self): ...

class DACatchAll(DAObject):
    def data_type_guess(self) -> None: ...
    context: str
    def __dir__(self) -> None: ...
    operand: Incomplete
    def __contains__(self, item) -> bool: ...
    def __iter__(self): ...
    def __len__(self) -> int: ...
    def __reversed__(self) -> None: ...
    def __getitem__(self, index) -> None: ...
    def __add__(self, other) -> None: ...
    def __sub__(self, other) -> None: ...
    def __mul__(self, other) -> None: ...
    def __floordiv__(self, other) -> None: ...
    def __mod__(self, other) -> None: ...
    def __divmod__(self, other) -> None: ...
    def __pow__(self, other) -> None: ...
    def __lshift__(self, other) -> None: ...
    def __rshift__(self, other) -> None: ...
    def __and__(self, other) -> None: ...
    def __xor__(self, other) -> None: ...
    def __or__(self, other) -> None: ...
    def __div__(self, other) -> None: ...
    def __truediv__(self, other) -> None: ...
    def __radd__(self, other) -> None: ...
    def __rsub__(self, other) -> None: ...
    def __rmul__(self, other) -> None: ...
    def __rdiv__(self, other) -> None: ...
    def __rtruediv__(self, other) -> None: ...
    def __rfloordiv__(self, other) -> None: ...
    def __rmod__(self, other) -> None: ...
    def __rdivmod__(self, other) -> None: ...
    def __rpow__(self, other) -> None: ...
    def __rlshift__(self, other) -> None: ...
    def __rrshift__(self, other) -> None: ...
    def __rand__(self, other) -> None: ...
    def __ror__(self, other) -> None: ...
    def __neg__(self) -> None: ...
    def __pos__(self) -> None: ...
    def __abs__(self) -> None: ...
    def __invert__(self) -> None: ...
    def __complex__(self) -> complex: ...
    def __int__(self) -> int: ...
    def __float__(self) -> float: ...
    def __oct__(self) -> None: ...
    def __hex__(self) -> None: ...
    def __index__(self) -> int: ...
    def __le__(self, other): ...
    def __ge__(self, other): ...
    def __gt__(self, other): ...
    def __lt__(self, other): ...
    def __eq__(self, other): ...
    def __ne__(self, other): ...
    def __hash__(self): ...
    def __bool__(self) -> bool: ...

class RelationshipDir(DAObject):
    def involves(self, target) -> None: ...

class RelationshipPeer(DAObject):
    def involves(self, target) -> None: ...

class RelationshipTree(DAObject):
    def init(self, *pargs, **kwargs) -> None: ...
    def new(self, *pargs, **kwargs) -> None: ...
    def query_peer(self, *pargs, **kwargs) -> None: ...
    def query_dir(self, *pargs, **kwargs) -> None: ...
    def add_relationship_dir(self, parent: Union[Incomplete, None] = ..., child: Union[Incomplete, None] = ..., relationship_type: Union[Incomplete, None] = ...): ...
    def delete_dir(self, *pargs) -> None: ...
    def add_relationship_peer(self, *pargs, **kwargs) -> None: ...
    def delete_peer(self, *pargs) -> None: ...

class DAList(DAObject):
    elements: Incomplete
    auto_gather: bool
    ask_number: bool
    minimum_number: Incomplete
    there_are_any: bool
    gathered: bool
    revisit: bool
    object_type: Incomplete
    object_type_parameters: Incomplete
    complete_attribute: Incomplete
    ask_object_type: bool
    def init(self, *pargs, **kwargs) -> None: ...
    def initializeObject(self, *pargs, **kwargs) -> None: ...
    def set_object_type(self, object_type) -> None: ...
    doing_gathered_and_complete: bool
    def gathered_and_complete(self) -> None: ...
    def item_name(self, item) -> None: ...
    def delitem(self, *pargs) -> None: ...
    def copy(self) -> None: ...
    def filter(self, *pargs, **kwargs) -> None: ...
    def reset_gathered(self, recursive: bool = ..., only_if_empty: bool = ..., mark_incomplete: bool = ...) -> None: ...
    def has_been_gathered(self) -> None: ...
    def pop(self, *pargs) -> None: ...
    def item(self, index) -> None: ...
    def __add__(self, other) -> None: ...
    def __radd__(self, other) -> None: ...
    def index(self, *pargs, **kwargs) -> None: ...
    def clear(self) -> None: ...
    def fix_instance_name(self, old_instance_name, new_instance_name) -> None: ...
    def sort(self, *pargs, **kwargs) -> None: ...
    def reverse(self, *pargs, **kwargs) -> None: ...
    def sort_elements(self, *pargs, **kwargs) -> None: ...
    def appendObject(self, *pargs, **kwargs) -> None: ...
    def append(self, *pargs, **kwargs) -> None: ...
    def remove(self, *pargs) -> None: ...
    def insert(self, *pargs) -> None: ...
    def count(self, item) -> None: ...
    def extend(self, the_list) -> None: ...
    def first(self) -> None: ...
    def last(self) -> None: ...
    def does_verb(self, the_verb, **kwargs) -> None: ...
    def did_verb(self, the_verb, **kwargs) -> None: ...
    def as_singular_noun(self) -> None: ...
    def possessive(self, target, **kwargs) -> None: ...
    def quantity_noun(self, *pargs, **kwargs) -> None: ...
    def as_noun(self, *pargs, **kwargs) -> None: ...
    def number(self) -> None: ...
    def gathering_started(self) -> None: ...
    def number_gathered(self, if_started: bool = ...): ...
    def current_index(self) -> None: ...
    def number_as_word(self, language: Union[Incomplete, None] = ..., capitalize: bool = ...): ...
    def complete_elements(self, complete_attribute: Union[Incomplete, None] = ...): ...
    def gather(self, number: Union[Incomplete, None] = ..., item_object_type: Union[Incomplete, None] = ..., minimum: Union[Incomplete, None] = ..., complete_attribute: Union[Incomplete, None] = ...): ...
    def comma_and_list(self, **kwargs) -> None: ...
    def __contains__(self, item) -> bool: ...
    def __iter__(self): ...
    def __len__(self) -> int: ...
    def __delitem__(self, index) -> None: ...
    def __reversed__(self) -> None: ...
    def __setitem__(self, index, the_value) -> None: ...
    def __getitem__(self, index) -> None: ...
    def union(self, other_set) -> None: ...
    def intersection(self, other_set) -> None: ...
    def difference(self, other_set) -> None: ...
    def isdisjoint(self, other_set) -> None: ...
    def issubset(self, other_set) -> None: ...
    def issuperset(self, other_set) -> None: ...
    def pronoun_possessive(self, target, **kwargs) -> None: ...
    def pronoun(self, **kwargs) -> None: ...
    def pronoun_objective(self, **kwargs) -> None: ...
    def pronoun_subjective(self, **kwargs) -> None: ...
    def item_actions(self, *pargs, **kwargs) -> None: ...
    def add_action(self, label: Union[Incomplete, None] = ..., message: Union[Incomplete, None] = ..., url_only: bool = ..., icon: str = ..., color: Union[Incomplete, None] = ..., size: str = ..., block: Union[Incomplete, None] = ..., classname: Union[Incomplete, None] = ...): ...
    def hook_on_gather(self, *pargs, **kwargs) -> None: ...
    def hook_after_gather(self, *pargs, **kwargs) -> None: ...
    def hook_on_item_complete(self, item, *pargs, **kwargs) -> None: ...
    def hook_on_remove(self, item, *pargs, **kwargs) -> None: ...
    def __eq__(self, other): ...
    def __hash__(self): ...

class DADict(DAObject):
    elements: Incomplete
    auto_gather: bool
    ask_number: bool
    minimum_number: Incomplete
    gathered: bool
    revisit: bool
    object_type: Incomplete
    object_type_parameters: Incomplete
    complete_attribute: Incomplete
    ask_object_type: bool
    def init(self, *pargs, **kwargs) -> None: ...
    def set_object_type(self, object_type) -> None: ...
    def fix_instance_name(self, old_instance_name, new_instance_name) -> None: ...
    def item_name(self, item) -> None: ...
    def delitem(self, *pargs) -> None: ...
    def invalidate_item(self, *pargs) -> None: ...
    def getitem_fresh(self, item) -> None: ...
    def all_false(self, *pargs, **kwargs) -> None: ...
    def any_true(self, *pargs, **kwargs) -> None: ...
    def any_false(self, *pargs, **kwargs) -> None: ...
    def all_true(self, *pargs, **kwargs) -> None: ...
    def true_values(self, insertion_order: bool = ...): ...
    def false_values(self, insertion_order: bool = ...): ...
    there_are_any: bool
    def initializeObject(self, *pargs, **kwargs) -> None: ...
    def new(self, *pargs, **kwargs) -> None: ...
    def reset_gathered(self, recursive: bool = ..., only_if_empty: bool = ..., mark_incomplete: bool = ...) -> None: ...
    def slice(self, *pargs) -> None: ...
    def has_been_gathered(self) -> None: ...
    def does_verb(self, the_verb, **kwargs) -> None: ...
    def did_verb(self, the_verb, **kwargs) -> None: ...
    def as_singular_noun(self) -> None: ...
    def quantity_noun(self, *pargs, **kwargs) -> None: ...
    def as_noun(self, *pargs, **kwargs) -> None: ...
    def possessive(self, target, **kwargs) -> None: ...
    def number(self) -> None: ...
    def gathering_started(self) -> None: ...
    def number_gathered(self, if_started: bool = ...): ...
    def number_as_word(self, language: Union[Incomplete, None] = ...): ...
    def complete_elements(self, complete_attribute: Union[Incomplete, None] = ...): ...
    doing_gathered_and_complete: bool
    def gathered_and_complete(self) -> None: ...
    def gather(self, item_object_type: Union[Incomplete, None] = ..., number: Union[Incomplete, None] = ..., minimum: Union[Incomplete, None] = ..., complete_attribute: Union[Incomplete, None] = ..., keys: Union[Incomplete, None] = ...): ...
    def comma_and_list(self, **kwargs) -> None: ...
    def __getitem__(self, index) -> None: ...
    def __setitem__(self, key, the_value) -> None: ...
    def __contains__(self, item) -> bool: ...
    def keys(self) -> None: ...
    def values(self) -> None: ...
    def update(self, *pargs, **kwargs) -> None: ...
    def pop(self, *pargs) -> None: ...
    def popitem(self) -> None: ...
    def setdefault(self, *pargs) -> None: ...
    def get(self, *pargs) -> None: ...
    def clear(self) -> None: ...
    def copy(self) -> None: ...
    def has_key(self, key) -> None: ...
    def item(self, key) -> None: ...
    def items(self) -> None: ...
    def iteritems(self) -> None: ...
    def iterkeys(self) -> None: ...
    def itervalues(self) -> None: ...
    def __iter__(self): ...
    def __len__(self) -> int: ...
    def __reversed__(self) -> None: ...
    def __delitem__(self, key) -> None: ...
    def __missing__(self, key) -> None: ...
    def union(self, other_set) -> None: ...
    def intersection(self, other_set) -> None: ...
    def difference(self, other_set) -> None: ...
    def isdisjoint(self, other_set) -> None: ...
    def issubset(self, other_set) -> None: ...
    def issuperset(self, other_set) -> None: ...
    def pronoun_possessive(self, target, **kwargs) -> None: ...
    def pronoun(self, **kwargs) -> None: ...
    def pronoun_objective(self, **kwargs) -> None: ...
    def pronoun_subjective(self, **kwargs) -> None: ...
    def item_actions(self, *pargs, **kwargs) -> None: ...
    def add_action(self, label: Union[Incomplete, None] = ..., message: Union[Incomplete, None] = ..., url_only: bool = ..., icon: str = ..., color: Union[Incomplete, None] = ..., size: str = ..., block: Union[Incomplete, None] = ..., classname: Union[Incomplete, None] = ...): ...
    def hook_on_gather(self, *pargs, **kwargs) -> None: ...
    def hook_after_gather(self, *pargs, **kwargs) -> None: ...
    def hook_on_item_complete(self, item, *pargs, **kwargs) -> None: ...
    def hook_on_remove(self, item, *pargs, **kwargs) -> None: ...
    def __eq__(self, other): ...
    def __hash__(self): ...

class DAOrderedDict(DADict): ...

class DASet(DAObject):
    elements: Incomplete
    auto_gather: bool
    ask_number: bool
    minimum_number: Incomplete
    gathered: bool
    revisit: bool
    def init(self, *pargs, **kwargs) -> None: ...
    doing_gathered_and_complete: bool
    def gathered_and_complete(self) -> None: ...
    def complete_elements(self, complete_attribute: Union[Incomplete, None] = ...): ...
    def filter(self, *pargs, **kwargs) -> None: ...
    def reset_gathered(self, recursive: bool = ..., only_if_empty: bool = ..., mark_incomplete: bool = ...) -> None: ...
    def has_been_gathered(self) -> None: ...
    def copy(self) -> None: ...
    def clear(self) -> None: ...
    there_are_any: bool
    def remove(self, elem) -> None: ...
    def discard(self, elem) -> None: ...
    def pop(self) -> None: ...
    def add(self, *pargs) -> None: ...
    def does_verb(self, the_verb, **kwargs) -> None: ...
    def did_verb(self, the_verb, **kwargs) -> None: ...
    def as_singular_noun(self) -> None: ...
    def quantity_noun(self, *pargs, **kwargs) -> None: ...
    def as_noun(self, *pargs, **kwargs) -> None: ...
    def number(self) -> None: ...
    def gathering_started(self) -> None: ...
    def number_gathered(self, if_started: bool = ...): ...
    def number_as_word(self, language: Union[Incomplete, None] = ...): ...
    def gather(self, number: Union[Incomplete, None] = ..., minimum: Union[Incomplete, None] = ...): ...
    def comma_and_list(self, **kwargs) -> None: ...
    def __contains__(self, item) -> bool: ...
    def __iter__(self): ...
    def __len__(self) -> int: ...
    def __reversed__(self) -> None: ...
    def __and__(self, operand) -> None: ...
    def __or__(self, operand) -> None: ...
    def __iand__(self, operand) -> None: ...
    def __ior__(self, operand) -> None: ...
    def __isub__(self, operand) -> None: ...
    def __ixor__(self, operand) -> None: ...
    def __rand__(self, operand) -> None: ...
    def __ror__(self, operand) -> None: ...
    def __hash__(self): ...
    def __add__(self, other) -> None: ...
    def __sub__(self, other) -> None: ...
    def union(self, other_set) -> None: ...
    def intersection(self, other_set) -> None: ...
    def difference(self, other_set) -> None: ...
    def isdisjoint(self, other_set) -> None: ...
    def issubset(self, other_set) -> None: ...
    def issuperset(self, other_set) -> None: ...
    def pronoun_possessive(self, target, **kwargs) -> None: ...
    def pronoun(self, **kwargs) -> None: ...
    def pronoun_objective(self, **kwargs) -> None: ...
    def pronoun_subjective(self, **kwargs) -> None: ...
    def hook_on_gather(self, *pargs, **kwargs) -> None: ...
    def hook_after_gather(self, *pargs, **kwargs) -> None: ...
    def hook_on_item_complete(self, item, *pargs, **kwargs) -> None: ...
    def hook_on_remove(self, item, *pargs, **kwargs) -> None: ...
    def __eq__(self, other): ...

class DAFile(DAObject):
    filename: Incomplete
    has_specific_filename: bool
    mimetype: Incomplete
    extension: Incomplete
    content: Incomplete
    markdown: Incomplete
    alt_text: Incomplete
    number: Incomplete
    ok: bool
    initialized: bool
    def init(self, *pargs, **kwargs) -> None: ...
    def convert_to(self, output_extension, output_to: Union[Incomplete, None] = ...) -> None: ...
    def fix_up(self) -> None: ...
    def set_alt_text(self, alt_text) -> None: ...
    def get_alt_text(self) -> None: ...
    def set_mimetype(self, mimetype) -> None: ...
    def initialize(self, **kwargs) -> None: ...
    file_info: Incomplete
    persistent: Incomplete
    private: Incomplete
    def retrieve(self) -> None: ...
    def size_in_bytes(self) -> None: ...
    def slurp(self, auto_decode: bool = ...): ...
    def readlines(self) -> None: ...
    def write(self, content, binary: bool = ...) -> None: ...
    def copy_into(self, other_file) -> None: ...
    def extract_pages(self, first: Union[Incomplete, None] = ..., last: Union[Incomplete, None] = ..., output_to: Union[Incomplete, None] = ...): ...
    def bates_number(self, *pargs, **kwargs) -> None: ...
    def make_ocr_pdf(self, *pargs, **kwargs) -> None: ...
    def make_ocr_pdf_in_background(self, *pargs, **kwargs) -> None: ...
    def get_docx_variables(self) -> None: ...
    def get_pdf_fields(self) -> None: ...
    def from_url(self, url) -> None: ...
    def uses_acroform(self) -> None: ...
    def is_encrypted(self) -> None: ...
    def pngs_ready(self) -> None: ...
    def num_pages(self) -> None: ...
    def page_path(self, page, prefix, wait: bool = ...): ...
    def cloud_path(self, filename: Union[Incomplete, None] = ...): ...
    def path(self) -> None: ...
    def commit(self) -> None: ...
    def show(self, width: Union[Incomplete, None] = ..., wait: bool = ..., alt_text: Union[Incomplete, None] = ...): ...
    def url_for(self, **kwargs) -> None: ...
    def set_attributes(self, **kwargs) -> None: ...
    def user_access(self, *pargs, **kwargs) -> None: ...
    def privilege_access(self, *pargs, **kwargs) -> None: ...

class DAFileCollection(DAObject):
    info: Incomplete
    def init(self, *pargs, **kwargs) -> None: ...
    def fix_up(self) -> None: ...
    def set_alt_text(self, alt_text) -> None: ...
    def get_alt_text(self) -> None: ...
    def uses_acroform(self) -> None: ...
    def is_encrypted(self) -> None: ...
    def num_pages(self) -> None: ...
    def path(self) -> None: ...
    def get_docx_variables(self) -> None: ...
    def get_pdf_fields(self) -> None: ...
    def url_for(self, **kwargs) -> None: ...
    def set_attributes(self, **kwargs) -> None: ...
    def user_access(self, *pargs, **kwargs) -> None: ...
    def privilege_access(self, *pargs, **kwargs) -> None: ...
    def show(self, **kwargs) -> None: ...
    def extract_pages(self, first: Union[Incomplete, None] = ..., last: Union[Incomplete, None] = ...): ...
    def bates_number(self, **kwargs) -> None: ...
    def make_ocr_pdf(self, **kwargs) -> None: ...
    def make_ocr_pdf_in_background(self, **kwargs) -> None: ...

class DAFileList(DAList):
    def fix_up(self) -> None: ...
    def set_alt_text(self, alt_text) -> None: ...
    def get_alt_text(self) -> None: ...
    def num_pages(self) -> None: ...
    def uses_acroform(self) -> None: ...
    def is_encrypted(self) -> None: ...
    def convert_to(self, output_extension, output_to: Union[Incomplete, None] = ...) -> None: ...
    def size_in_bytes(self) -> None: ...
    def slurp(self, auto_decode: bool = ...): ...
    def show(self, width: Union[Incomplete, None] = ..., alt_text: Union[Incomplete, None] = ...): ...
    def path(self) -> None: ...
    def get_docx_variables(self) -> None: ...
    def get_pdf_fields(self) -> None: ...
    def url_for(self, **kwargs) -> None: ...
    def set_attributes(self, **kwargs) -> None: ...
    def user_access(self, *pargs, **kwargs) -> None: ...
    def privilege_access(self, *pargs, **kwargs) -> None: ...
    def extract_pages(self, first: Union[Incomplete, None] = ..., last: Union[Incomplete, None] = ...): ...
    elements: Incomplete
    def bates_number(self, **kwargs) -> None: ...
    def make_ocr_pdf(self, **kwargs) -> None: ...
    def make_ocr_pdf_in_background(self, **kwargs) -> None: ...

class DAStaticFile(DAObject):
    package: Incomplete
    def init(self, *pargs, **kwargs) -> None: ...
    def get_alt_text(self) -> None: ...
    alt_text: Incomplete
    def set_alt_text(self, alt_text) -> None: ...
    def show(self, width: Union[Incomplete, None] = ..., alt_text: Union[Incomplete, None] = ...): ...
    def uses_acroform(self) -> None: ...
    def is_encrypted(self) -> None: ...
    def size_in_bytes(self) -> None: ...
    def slurp(self, auto_decode: bool = ...): ...
    def path(self) -> None: ...
    def get_docx_variables(self) -> None: ...
    def get_pdf_fields(self) -> None: ...
    def url_for(self, **kwargs) -> None: ...

class DAEmailRecipientList(DAList):
    object_type: Incomplete
    def init(self, *pargs, **kwargs) -> None: ...

class DAEmailRecipient(DAObject):
    address: Incomplete
    name: Incomplete
    def init(self, *pargs, **kwargs) -> None: ...
    def email_address(self, include_name: Union[Incomplete, None] = ...): ...
    def exists(self) -> None: ...

class DAEmail(DAObject): ...

class DATemplate(DAObject):
    content: Incomplete
    subject: Incomplete
    decorations: Incomplete
    def init(self, *pargs, **kwargs) -> None: ...
    def show(self, **kwargs) -> None: ...
    def show_as_markdown(self, **kwargs) -> None: ...

class DALazyTemplate(DAObject):
    def subject_as_html(self, **kwargs) -> None: ...
    def content_as_html(self, **kwargs) -> None: ...
    @property
    def subject(self, **kwargs) -> None: ...
    @property
    def content(self, **kwargs) -> None: ...
    @property
    def decorations(self) -> None: ...
    def show(self, **kwargs) -> None: ...
    def show_as_markdown(self, **kwargs) -> None: ...

class DALazyTableTemplate(DALazyTemplate):
    def show(self, **kwargs) -> None: ...
    @property
    def content(self, **kwargs) -> None: ...
    def export(self, filename: Union[Incomplete, None] = ..., file_format: Union[Incomplete, None] = ..., title: Union[Incomplete, None] = ..., freeze_panes: bool = ..., output_to: Union[Incomplete, None] = ...): ...
    def as_df(self) -> None: ...
    def export_safe_eval(self, x, user_dict_copy) -> None: ...
    def header_and_contents(self) -> None: ...

def selections(*pargs, **kwargs) -> None: ...
def objects_from_file(file_ref, recursive: bool = ..., gathered: bool = ..., name: Union[Incomplete, None] = ..., use_objects: bool = ..., package: Union[Incomplete, None] = ...): ...

class DALink(DAObject):
    def show(self) -> None: ...

class DAContext(DADict):
    pargs: Incomplete
    kwargs: Incomplete
    def init(self, *pargs, **kwargs) -> None: ...
    def __hash__(self): ...

class DASessionLocal(DAObject):
    def __init__(self, *pargs, **kwargs) -> None: ...

class DADeviceLocal(DAObject):
    def __init__(self, *pargs, **kwargs) -> None: ...

class DAUserLocal(DAObject):
    def __init__(self, *pargs, **kwargs) -> None: ...

class DAGlobal(DAObject):
    @classmethod
    def keys(cls, base) -> None: ...
    @classmethod
    def defined(cls, base, key) -> None: ...
    base: str
    key: Incomplete
    def init(self, *pargs, **kwargs) -> None: ...
    __dict__: Incomplete
    def delete(self) -> None: ...

class DAStore(DAObject):
    def is_encrypted(self) -> None: ...
    def defined(self, key) -> None: ...
    def get(self, key) -> None: ...
    def set(self, key, the_value) -> None: ...
    def delete(self, key) -> None: ...
    def keys(self) -> None: ...

class DAWeb(DAObject):
    def get(self, url, data: Union[Incomplete, None] = ..., params: Union[Incomplete, None] = ..., headers: Union[Incomplete, None] = ..., json_body: Union[Incomplete, None] = ..., on_failure: Union[Incomplete, None] = ..., on_success: Union[Incomplete, None] = ..., auth: Union[Incomplete, None] = ..., cookies: Union[Incomplete, None] = ..., task: Union[Incomplete, None] = ..., task_persistent: Union[Incomplete, None] = ...): ...
    def post(self, url, data: Union[Incomplete, None] = ..., params: Union[Incomplete, None] = ..., headers: Union[Incomplete, None] = ..., json_body: Union[Incomplete, None] = ..., on_failure: Union[Incomplete, None] = ..., on_success: Union[Incomplete, None] = ..., auth: Union[Incomplete, None] = ..., cookies: Union[Incomplete, None] = ..., task: Union[Incomplete, None] = ..., task_persistent: Union[Incomplete, None] = ..., files: Union[Incomplete, None] = ...): ...
    def put(self, url, data: Union[Incomplete, None] = ..., params: Union[Incomplete, None] = ..., headers: Union[Incomplete, None] = ..., json_body: Union[Incomplete, None] = ..., on_failure: Union[Incomplete, None] = ..., on_success: Union[Incomplete, None] = ..., auth: Union[Incomplete, None] = ..., cookies: Union[Incomplete, None] = ..., task: Union[Incomplete, None] = ..., task_persistent: Union[Incomplete, None] = ..., files: Union[Incomplete, None] = ...): ...
    def patch(self, url, data: Union[Incomplete, None] = ..., params: Union[Incomplete, None] = ..., headers: Union[Incomplete, None] = ..., json_body: Union[Incomplete, None] = ..., on_failure: Union[Incomplete, None] = ..., on_success: Union[Incomplete, None] = ..., auth: Union[Incomplete, None] = ..., cookies: Union[Incomplete, None] = ..., task: Union[Incomplete, None] = ..., task_persistent: Union[Incomplete, None] = ..., files: Union[Incomplete, None] = ...): ...
    def delete(self, url, data: Union[Incomplete, None] = ..., params: Union[Incomplete, None] = ..., headers: Union[Incomplete, None] = ..., json_body: Union[Incomplete, None] = ..., on_failure: Union[Incomplete, None] = ..., on_success: Union[Incomplete, None] = ..., auth: Union[Incomplete, None] = ..., cookies: Union[Incomplete, None] = ..., task: Union[Incomplete, None] = ..., task_persistent: Union[Incomplete, None] = ...): ...
    def options(self, url, data: Union[Incomplete, None] = ..., params: Union[Incomplete, None] = ..., headers: Union[Incomplete, None] = ..., json_body: Union[Incomplete, None] = ..., on_failure: Union[Incomplete, None] = ..., on_success: Union[Incomplete, None] = ..., auth: Union[Incomplete, None] = ..., cookies: Union[Incomplete, None] = ..., task: Union[Incomplete, None] = ..., task_persistent: Union[Incomplete, None] = ...): ...
    def head(self, url, data: Union[Incomplete, None] = ..., params: Union[Incomplete, None] = ..., headers: Union[Incomplete, None] = ..., json_body: Union[Incomplete, None] = ..., on_failure: Union[Incomplete, None] = ..., on_success: Union[Incomplete, None] = ..., auth: Union[Incomplete, None] = ..., cookies: Union[Incomplete, None] = ..., task: Union[Incomplete, None] = ..., task_persistent: Union[Incomplete, None] = ...): ...

class DARedis(DAObject):
    def key(self, keyname) -> None: ...
    def get_data(self, key) -> None: ...
    def set_data(self, key, data, expire: Union[Incomplete, None] = ...) -> None: ...
    def __getattr__(self, funcname) -> None: ...

class DACloudStorage(DAObject):
    custom: bool
    provider: Incomplete
    config: Incomplete
    def init(self, *pargs, **kwargs) -> None: ...
    @property
    def conn(self) -> None: ...
    @property
    def client(self) -> None: ...
    @property
    def bucket(self) -> None: ...
    @property
    def bucket_name(self) -> None: ...
    @property
    def container_name(self) -> None: ...

class DAGoogleAPI(DAObject):
    def api_credentials(self, scope) -> None: ...
    def http(self, scope) -> None: ...
    def drive_service(self) -> None: ...
    def cloud_credentials(self, scope) -> None: ...
    def project_id(self) -> None: ...
    def google_cloud_storage_client(self) -> None: ...
    def google_cloud_vision_client(self) -> None: ...

def run_python_module(module, arguments: Union[Incomplete, None] = ...): ...
def today(timezone: Union[Incomplete, None] = ..., format: Union[Incomplete, None] = ...): ...
def month_of(the_date, as_word: bool = ..., language: Union[Incomplete, None] = ...): ...
def day_of(the_date, language: Union[Incomplete, None] = ...): ...
def dow_of(the_date, as_word: bool = ..., language: Union[Incomplete, None] = ...): ...
def year_of(the_date, language: Union[Incomplete, None] = ...): ...
def format_date(the_date, format: Union[Incomplete, None] = ..., language: Union[Incomplete, None] = ...): ...
def format_datetime(the_date, format: Union[Incomplete, None] = ..., language: Union[Incomplete, None] = ...): ...
def format_time(the_time, format: Union[Incomplete, None] = ..., language: Union[Incomplete, None] = ...): ...

class DateTimeDelta:
    def describe(self, **kwargs) -> None: ...

class DADateTime(datetime.datetime):
    def format(self, format: Union[Incomplete, None] = ..., language: Union[Incomplete, None] = ...): ...
    def format_date(self, format: Union[Incomplete, None] = ..., language: Union[Incomplete, None] = ...): ...
    def format_datetime(self, format: Union[Incomplete, None] = ..., language: Union[Incomplete, None] = ...): ...
    def format_time(self, format: Union[Incomplete, None] = ..., language: Union[Incomplete, None] = ...): ...
    def replace_time(self, the_time) -> None: ...
    @property
    def nanosecond(self) -> None: ...
    @property
    def dow(self) -> None: ...
    @property
    def week(self) -> None: ...
    def plus(self, **kwargs) -> None: ...
    def minus(self, **kwargs) -> None: ...
    def __add__(self, other) -> None: ...
    def __radd__(self, other) -> None: ...
    def __sub__(self, other) -> None: ...
    def __rsub__(self, other) -> None: ...

def current_datetime(timezone: Union[Incomplete, None] = ...): ...
def as_datetime(the_date, timezone: Union[Incomplete, None] = ...): ...
def date_interval(**kwargs) -> None: ...
def date_difference(starting: Union[Incomplete, None] = ..., ending: Union[Incomplete, None] = ..., timezone: Union[Incomplete, None] = ...): ...
def timezone_list() -> None: ...
def returning_user(minutes: Union[Incomplete, None] = ..., hours: Union[Incomplete, None] = ..., days: Union[Incomplete, None] = ...): ...
def last_access_delta(*pargs, **kwargs) -> None: ...
def last_access_days(*pargs, **kwargs) -> None: ...
def last_access_hours(*pargs, **kwargs) -> None: ...
def last_access_minutes(*pargs, **kwargs) -> None: ...
def last_access_time(include_privileges: Union[Incomplete, None] = ..., exclude_privileges: Union[Incomplete, None] = ..., include_cron: bool = ..., timezone: Union[Incomplete, None] = ...): ...
def start_time(timezone: Union[Incomplete, None] = ...): ...

class LatitudeLongitude(DAObject):
    gathered: bool
    known: bool
    def init(self, *pargs, **kwargs) -> None: ...
    def status(self) -> None: ...

class RoleChangeTracker(DAObject):
    last_role: Incomplete
    def init(self, *pargs, **kwargs) -> None: ...
    def send_email(self, roles_needed, **kwargs) -> None: ...

class Name(DAObject):
    def full(self, **kwargs) -> None: ...
    def familiar(self) -> None: ...
    def firstlast(self) -> None: ...
    def lastfirst(self) -> None: ...
    def middle_initial(self, with_period: bool = ...): ...
    def defined(self) -> None: ...

class IndividualName(Name):
    uses_parts: bool
    def init(self, *pargs, **kwargs) -> None: ...
    def defined(self) -> None: ...
    def familiar(self) -> None: ...
    def full(self, middle: str = ..., use_suffix: bool = ...): ...
    def firstlast(self) -> None: ...
    def lastfirst(self) -> None: ...
    def middle_initial(self, with_period: bool = ...): ...

class Address(DAObject):
    LatitudeLongitudeClass: Incomplete
    geolocated: bool
    city_only: bool
    def init(self, *pargs, **kwargs) -> None: ...
    def on_one_line(self, include_unit: bool = ..., omit_default_country: bool = ..., language: Union[Incomplete, None] = ..., show_country: Union[Incomplete, None] = ...): ...
    def was_geocoded(self) -> None: ...
    def was_geocoded_successfully(self) -> None: ...
    def get_geocode_response(self) -> None: ...
    def geolocate(self, address: Union[Incomplete, None] = ..., reset: bool = ...): ...
    geolocate_success: bool
    geolocate_response: Incomplete
    def geocode(self, address: Union[Incomplete, None] = ..., reset: bool = ...): ...
    norm: Incomplete
    norm_long: Incomplete
    def normalize(self, long_format: bool = ...): ...
    def reset_geolocation(self) -> None: ...
    def reset_geocoding(self) -> None: ...
    def block(self, language: Union[Incomplete, None] = ..., international: bool = ..., show_country: Union[Incomplete, None] = ...): ...
    def formatted_unit(self, language: Union[Incomplete, None] = ..., require: bool = ...): ...
    def line_one(self, language: Union[Incomplete, None] = ...): ...
    def line_two(self, language: Union[Incomplete, None] = ...): ...

def iso_country(country, part: str = ...): ...

class City(Address):
    city_only: bool
    def init(self, *pargs, **kwargs) -> None: ...

class Thing(DAObject):
    NameClass: Incomplete
    def init(self, *pargs, **kwargs) -> None: ...
    def __setattr__(self, attrname, the_value) -> None: ...

class Event(DAObject):
    CityClass: Incomplete
    LatitudeLongitudeClass: Incomplete
    def init(self, *pargs, **kwargs) -> None: ...

class Person(DAObject):
    NameClass: Incomplete
    AddressClass: Incomplete
    LatitudeLongitudeClass: Incomplete
    def init(self, *pargs, **kwargs) -> None: ...
    def identified(self) -> None: ...
    def __setattr__(self, attrname, the_value) -> None: ...
    def pronoun_objective(self, **kwargs) -> None: ...
    def possessive(self, target, **kwargs) -> None: ...
    def object_possessive(self, target, **kwargs) -> None: ...
    def is_are_you(self, **kwargs) -> None: ...
    def is_user(self) -> None: ...
    def address_block(self, language: Union[Incomplete, None] = ..., international: bool = ..., show_country: bool = ...): ...
    def sms_number(self, country: Union[Incomplete, None] = ...): ...
    def facsimile_number(self, country: Union[Incomplete, None] = ...): ...
    def email_address(self, include_name: Union[Incomplete, None] = ...): ...
    def do_question(self, the_verb, **kwargs) -> None: ...
    def did_question(self, the_verb, **kwargs) -> None: ...
    def were_question(self, the_target, **kwargs) -> None: ...
    def have_question(self, the_target, **kwargs) -> None: ...
    def does_verb(self, the_verb, **kwargs) -> None: ...
    def did_verb(self, the_verb, **kwargs) -> None: ...
    def subject(self, **kwargs) -> None: ...

class Individual(Person):
    NameClass: Incomplete
    def init(self, *pargs, **kwargs) -> None: ...
    def familiar(self) -> None: ...
    def gather_family(self, tree, up: int = ..., down: int = ...) -> None: ...
    def identified(self) -> None: ...
    def age_in_years(self, decimals: bool = ..., as_of: Union[Incomplete, None] = ...): ...
    def first_name_hint(self) -> None: ...
    def last_name_hint(self) -> None: ...
    def salutation(self, **kwargs) -> None: ...
    def pronoun_possessive(self, target, **kwargs) -> None: ...
    def pronoun(self, **kwargs) -> None: ...
    def pronoun_objective(self, **kwargs) -> None: ...
    def pronoun_subjective(self, **kwargs) -> None: ...
    def yourself_or_name(self, **kwargs) -> None: ...
    def __setattr__(self, attrname, the_value) -> None: ...

class ChildList(DAList):
    ChildClass: Incomplete
    object_type: Incomplete
    def init(self, *pargs, **kwargs) -> None: ...

class Value(DAObject):
    def amount(self) -> None: ...
    def __float__(self) -> float: ...
    def __int__(self) -> int: ...
    def __le__(self, other): ...
    def __ge__(self, other): ...
    def __gt__(self, other): ...
    def __lt__(self, other): ...
    def __eq__(self, other): ...
    def __ne__(self, other): ...
    def __hash__(self): ...

class PeriodicValue(Value):
    def amount(self, period_to_use: int = ...): ...

class FinancialList(DADict):
    ValueClass: Incomplete
    object_type: Incomplete
    def init(self, *pargs, **kwargs) -> None: ...
    def total(self) -> None: ...
    def existing_items(self) -> None: ...

class PeriodicFinancialList(FinancialList):
    PeriodicValueClass: Incomplete
    object_type: Incomplete
    def init(self, *pargs, **kwargs) -> None: ...
    def total(self, period_to_use: int = ...): ...

class Income(PeriodicFinancialList): ...
class Asset(FinancialList): ...
class Expense(PeriodicFinancialList): ...

class OfficeList(DAList):
    AddressClass: Incomplete
    object_type: Incomplete
    def init(self, *pargs, **kwargs) -> None: ...

class Organization(Person):
    OfficeListClass: Incomplete
    def init(self, *pargs, **kwargs) -> None: ...
    def will_handle(self, problem: Union[Incomplete, None] = ..., county: Union[Incomplete, None] = ...): ...

def get_sms_session(phone_number, config: str = ...): ...
def initiate_sms_session(phone_number, yaml_filename: Union[Incomplete, None] = ..., email: Union[Incomplete, None] = ..., new: bool = ..., send: bool = ..., config: str = ...): ...
def terminate_sms_session(phone_number, config: str = ...): ...
def send_sms(to: Union[Incomplete, None] = ..., body: Union[Incomplete, None] = ..., template: Union[Incomplete, None] = ..., task: Union[Incomplete, None] = ..., task_persistent: bool = ..., attachments: Union[Incomplete, None] = ..., config: str = ..., dry_run: bool = ...): ...

class FaxStatus:
    sid: Incomplete
    def __init__(self, sid) -> None: ...
    def status(self) -> None: ...
    def pages(self) -> None: ...
    def info(self) -> None: ...
    def received(self) -> None: ...

def send_fax(fax_number, file_object, config: str = ..., country: Union[Incomplete, None] = ...): ...
def send_email(to: Union[Incomplete, None] = ..., sender: Union[Incomplete, None] = ..., reply_to: Union[Incomplete, None] = ..., cc: Union[Incomplete, None] = ..., bcc: Union[Incomplete, None] = ..., body: Union[Incomplete, None] = ..., html: Union[Incomplete, None] = ..., subject: str = ..., template: Union[Incomplete, None] = ..., task: Union[Incomplete, None] = ..., task_persistent: bool = ..., attachments: Union[Incomplete, None] = ..., mailgun_variables: Union[Incomplete, None] = ..., dry_run: bool = ...): ...
def map_of(*pargs, **kwargs) -> None: ...
def ocr_file_in_background(*pargs, **kwargs) -> None: ...
def ocr_file(image_file, language: Union[Incomplete, None] = ..., psm: int = ..., f: Union[Incomplete, None] = ..., l: Union[Incomplete, None] = ..., x: Union[Incomplete, None] = ..., y: Union[Incomplete, None] = ..., W: Union[Incomplete, None] = ..., H: Union[Incomplete, None] = ..., use_google: bool = ..., raw_result: bool = ...): ...
def read_qr(image_file, f: Union[Incomplete, None] = ..., l: Union[Incomplete, None] = ..., x: Union[Incomplete, None] = ..., y: Union[Incomplete, None] = ..., W: Union[Incomplete, None] = ..., H: Union[Incomplete, None] = ...): ...
def path_and_mimetype(file_ref) -> None: ...

class DummyObject:
    def __init__(self, *pargs, **kwargs) -> None: ...
SimpleTextMachineLearner = DummyObject
SVMMachineLearner = DummyObject
RandomForestMachineLearner = DummyObject
MachineLearningEntry = DummyObject

class DAModel(DAObject):
    store: Incomplete
    group_id: Incomplete
    key: Incomplete
    use_for_training: Incomplete
    learner: Incomplete
    text: Incomplete
    def init(self, *pargs, **kwargs) -> None: ...
    entry_id: Incomplete
    predictions: Incomplete
    prediction: Incomplete
    probability: Incomplete
    def predict(self) -> None: ...

def docx_concatenate(*pargs, **kwargs) -> None: ...
def pdf_concatenate(*pargs, **kwargs) -> None: ...
def zip_file(*pargs, **kwargs) -> None: ...
def validation_error(the_message, field: Union[Incomplete, None] = ...) -> None: ...
def url_ask(data) -> None: ...
def action_button_html(url, icon: Union[Incomplete, None] = ..., color: str = ..., size: str = ..., block: bool = ..., label: str = ..., classname: Union[Incomplete, None] = ..., new_window: Union[Incomplete, None] = ..., id_tag: Union[Incomplete, None] = ...): ...
def overlay_pdf(main_pdf, logo_pdf, first_page: Union[Incomplete, None] = ..., last_page: Union[Incomplete, None] = ..., logo_page: Union[Incomplete, None] = ..., only: Union[Incomplete, None] = ..., multi: bool = ..., output_to: Union[Incomplete, None] = ..., filename: Union[Incomplete, None] = ...): ...
def explain(the_explanation, category: str = ...) -> None: ...
def clear_explanations(category: str = ...) -> None: ...
def logic_explanation(category: str = ...): ...
def set_status(**kwargs) -> None: ...
def get_status(setting) -> None: ...
def assemble_docx(input_file, fields: Union[Incomplete, None] = ..., output_path: Union[Incomplete, None] = ..., output_format: str = ..., return_content: bool = ..., pdf_options: Union[Incomplete, None] = ..., filename: Union[Incomplete, None] = ...): ...
def task_performed(task, persistent: bool = ...): ...
def task_not_yet_performed(task, persistent: bool = ...): ...
def mark_task_as_performed(task, persistent: bool = ...): ...
def times_task_performed(task, persistent: bool = ...): ...
def set_task_counter(task, times, persistent: bool = ...) -> None: ...
def stash_data(data, expire: Union[Incomplete, None] = ...): ...
def retrieve_stashed_data(stash_key, secret, delete: bool = ..., refresh: bool = ...): ...

class DABreadCrumbs(DAObject):
    def get_crumbs(self) -> None: ...
    def show(self) -> None: ...
    def container(self, items) -> None: ...
    def inner(self, label, active) -> None: ...

class DAOAuth(DAObject):
    url_args: Incomplete
    def init(self, *pargs, **kwargs) -> None: ...
    def get_credentials(self) -> None: ...
    def delete_credentials(self) -> None: ...
    def get_http(self) -> None: ...
    def authorize(self, web) -> None: ...
    def ensure_authorized(self) -> None: ...
    def active(self) -> None: ...
    def is_authorized(self) -> None: ...

class RedisCredStorage(oauth2client.client.Storage):
    r: Incomplete
    key: Incomplete
    lockkey: Incomplete
    expires: Incomplete
    def __init__(self, key, lock, expires) -> None: ...
    def acquire_lock(self) -> None: ...
    def release_lock(self) -> None: ...
    def locked_get(self) -> None: ...
    def locked_put(self, credentials) -> None: ...
    def locked_delete(self) -> None: ...

def transform_json_variables(obj) -> None: ...
